---
id: intro-greedy
title: Introduction to Greedy Algorithms
author: Darren Yao
description: "Selecting the choice that seems to be the best at the moment at every step of your algorithm."
frequency: 2
prerequisites:
 - ad-hoc
 - intro-ds
---

import { Problem } from "../models";

export const problems = {
    tutorial: [
      new Problem("Bronze", "Mad Scientist", "1012", "Easy", false, [], ""),
    ],
    general: [
      new Problem("Bronze", "Cow Tipping", "689", "Normal", false, [], "Cells in the last row and column can be toggled uniquely. Toggle the appropriate ones and then recurse to the rectangle in the previous row/column, and solve the same way."),
      new Problem("Bronze", "Out of Place", "785", "Hard", false, [], ""),
      new Problem("Bronze", "Race", "989", "Very Hard", false, [], "Greedily increment/decrement Bessies speed to fit the conditions until her total distance exceeds K."),
    ],
};

## Greedy Algorithms

Some USACO Bronze problems that appear to be Ad Hoc can actually be solved using **greedy** algorithms. This idea will be covered in a future [module](../silver/greedy), but we'll introduce the general mindset in this section.

<Resources>
  <Resource source="CPH" title="6.1 - Coin Problem" starred>other examples are outside scope of bronze</Resource>
</Resources>

From the above:

> A **greedy** algorithm constructs a solution to the problem by always making a
choice that looks the best at the moment. A greedy algorithm never takes back
its choices, but directly constructs the final solution. For this reason, greedy
algorithms are usually very efficient.

**Greedy** does not refer to a single algorithm, but rather a way of thinking that is applied to problems; there's no one way to do greedy algorithms. Hence, we use a selection of well-known examples to help you understand the greedy paradigm. 

### Example: Mad Scientist

Try to come up with a greedy algorithm for the USACO Bronze problem "Mad Scientist."

<Problems problems={problems.tutorial} />

<Spoiler title="Correct Greedy Algorithm">

In this problem, the correct greedy solution is to continually flip the longest possible ranges of mismatching cows. 

Mad Scientist has an excellent [editorial](http://www.usaco.org/current/data/sol_breedflip_bronze_feb20.html) with a video solution and intuitive proof. 

It is highly recommended you read it to gain a better understanding of the greedy algorithm.

</Spoiler>

However, not all greedy problems in the bronze division necessarily require mathematical proofs of correctness. It is often sufficent to intuitively convince yourself your algorithm is correct.

<Info title="Pro Tip">

Sometimes, if the algorithm is easy enough to implement, you don't even need to convince yourself it's correct; just code it and see if it passes. Competitive programmers refer to this as "Proof by AC," or "Proof by Accepted."

<!-- Don't overuse it though? -->

</Info>

## Problems

<Problems problems={problems.general} />

<IncompleteSection>

</IncompleteSection>

<!-- Anything else major that needs to be added? Bronze Ad Hoc is not very complicated. -->

