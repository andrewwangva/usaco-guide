---
id: mst
title: 'Minimum Spanning Trees'
author: Benjamin Qi, Andrew Wang
prerequisites:
  - sp
  - dsu
description: 'A subset of the edges of a connected, undirected, edge-weighted graph that connects all the vertices to each other of minimum total weight, where no cycles are allowed.'
frequency: 2
---

import { Problem } from '../models';

export const problems = {
	standard: [
		new Problem('CSES', 'Road Reparation', '1675', 'Easy', false, ['MST'], ''),
	],
	general: [
		new Problem(
			'Old Silver',
			'Superbull',
			'531',
			'Easy',
			false,
			['MST', 'Prim'],
			''
		),
		new Problem('Gold', 'Fenced In', '623', 'Easy', false, ['MST'], ''),
		new Problem(
			'Gold',
			'I Would Walk 500 Miles',
			'946',
			'Normal',
			false,
			['Math', 'Prim'],
			'usaco-946'
		),
		new Problem(
			'HR',
			'Spanning Tree Fraction',
			'https://www.hackerrank.com/contests/w31/challenges/spanning-tree-fraction/problem',
			'Normal',
			false,
			['MST', 'Binary Search'],
			''
		),
		new Problem('Plat', 'Fenced In', '625', 'Hard', false, ['Kruskal'], ''),
	],
};

To review a couple of terms:
- An **undirected edge** is an edge that goes both ways
- A **connected graph** is a graph of vertices such that each vertex can reach every other vertex using undirected edges.
- A **spanning tree** is a subgraph that is a tree which contains every vertex in the original graph
- A **minimum spanning tree** is a spanning tree such that the sum of edge weights are minimized

<!-- Prim's is recommended; Kruskal's algorithm might TLE -->

<FocusProblem problem={problems.standard[0]} />

<!-- new Problem("Kattis", "MST", "minspantree", "Easy", false, ["MST"], ""), -->

## Kruskal's

<Resources>
	<Resource source="CPH" title="15.1 - Kruskal's" starred></Resource>
	<Resource
		source="cp-algo"
		title="Kruskal's"
		url="graph/mst_kruskal.html"
	></Resource>
	<Resource
		source="cp-algo"
		title="Kruskal's with DSU"
		url="graph/mst_kruskal_with_dsu.html"
	></Resource>
	<Resource source="CP2" title="4.3.2 - Kruskal's">
		{' '}
	</Resource>
</Resources>

<!-- 	<Resource source="PAPS" title="12.4 - Kruskal's">
		description, example, explanation of correctness
	</Resource> -->

### Solution - Road Reparation

<LanguageSection>

<CPPSection>

<Resources>
	<Resource
		source="Benq (from KACTL)"
		url="https://github.com/bqi343/USACO/blob/master/Implementations/content/graphs%20(12)/DSU/DSU%20(7.6).h"
		title="DSU"
	>
		Disjoint Set Union + Kruskal
	</Resource>
</Resources>

```cpp
#include "DSU.h"

template<class T> T kruskal(int N, vector<pair<T,pi>> ed) {
	sort(all(ed));
	T ans = 0; DSU D; D.init(N); // edges that unite are in MST
	trav(a,ed) if (D.unite(a.s.f,a.s.s)) ans += a.f;
	return ans;
}
```

</CPPSection>

<JavaSection>
	
```java
import java.io.*; 
import java.util.*; 
 
public class prim{
   public static Map<Integer, ArrayList<Edge>> tree;
   public static int N, ct;
   public static long[] dist;
   public static long max = 10000000000000000L;
   public static void main(String[] args) throws IOException
   {
      BufferedReader sc = new BufferedReader(new InputStreamReader(System.in));
      PrintWriter out = new PrintWriter(System.out);
      StringTokenizer st = new StringTokenizer(sc.readLine());
      N = Integer.parseInt(st.nextToken());
      int M = Integer.parseInt(st.nextToken());
      tree = new HashMap<Integer, ArrayList<Edge>>();
      for(int i = 1; i <= N; i++){
         tree.put(i, new ArrayList<Edge>());
      }
      for(int m = 0; m < M; m++){
         st = new StringTokenizer(sc.readLine());
         int a = Integer.parseInt(st.nextToken());
         int b = Integer.parseInt(st.nextToken());
         int w = Integer.parseInt(st.nextToken());
         tree.get(a).add(new Edge(a,b,w));
         tree.get(b).add(new Edge(b,a,w));
      }
      long ans = prim(1);
      out.println((ct == N) ? ans : "IMPOSSIBLE");
      out.close();
   }
   public static long prim(int source){
      dist = new long[N+1];
      boolean[] visited= new boolean[N+1];
      PriorityQueue<Pair> pq = new PriorityQueue<Pair>();
      Arrays.fill(dist, max);
      dist[source] = 0;
      long ret = 0;
      pq.add(new Pair(0, source));
      while(!pq.isEmpty()){
         Pair p = pq.poll();
         int v = p.b;
         if(visited[v]){
            continue;
         }
         visited[v] = true; ct++; ret += dist[v];
         for(Edge e : tree.get(v)){
            if(e.weight < dist[e.end] && !visited[e.end]){
               dist[e.end] = e.weight;
               pq.add(new Pair(dist[e.end], e.end));
            }
         }
      }
      return ret;
   }
}
class Edge{
   int start, end, weight;
   public Edge(int s, int e, int w){
      start = s;
      end = e;
      weight = w;
   }
}
class Pair implements Comparable<Pair>{
   public long a;
   public int b;
   public Pair(long a, int b){
      this.a = a;
      this.b = b;
   }
   public int compareTo(Pair o){
      if(this.a > o.a){
         return 1;
      }
      else if(this.a == o.a){
         return 0;
      }
      else{
         return -1;
      }
   }
}
```
</JavaSection>
</LanguageSection>

## Prim's

<Resources>
	<Resource source="CPH" title="15.3 - Prim's" starred></Resource>
	<Resource
		source="cp-algo"
		title="Prim's"
		url="graph/mst_prim.html"
	></Resource>
	<Resource source="CP2" title="4.3.3 - Prim's">
		{' '}
	</Resource>
</Resources>

### Solution - Road Reparation

<LanguageSection>

<CPPSection>


</CPPSection>

<JavaSection>
	
Rather than greedily adding edges, Prim's algorithm greedily adds vertices, similar to Djikstras. On each iteration, we add the vertex that is closest to the current MST(Instead of closest to the source in Djikstra) until all vertices have been added. The process of finding the closest vertex to the MST can be done efficiently using a priority queue in $O(\log N)$ . After removing a vertex, we add all of its neighbors that are not yet in the MST to the priority queue and repeat. To begin the algorithm, we simply add any vertex to the priority queue. Note that Prim's algorithm has complexity $O(E \log E)$ since in the worst case every edge will be checked and its corresponding vertex will be added to the priority queue. However, this can be improved to $O(E \log V)$ if we were to update the distances of vertices rather than re-add them. This keeps the maximum size of the priority queue bounded at $V$. 

Alternatively, we may linearly search for the closest vertex instead of using a priority queue. Each linear pass runs in time $O(V)$, and this must be repeated $V$ times. Thus, this version of Prim's algorithm has complexity $O(V^2)$. Note that this complexity is preferable for dense graphs (in which $E \approx V^2$). 



```java
import java.io.*; 
import java.util.*; 
 
public class prim{
   public static Map<Integer, ArrayList<Edge>> tree;
   public static int N, ct;
   public static long[] dist;
   public static long max = 10000000000000000L;
   public static void main(String[] args) throws IOException
   {
      BufferedReader sc = new BufferedReader(new InputStreamReader(System.in));
      PrintWriter out = new PrintWriter(System.out);
      StringTokenizer st = new StringTokenizer(sc.readLine());
      N = Integer.parseInt(st.nextToken());
      int M = Integer.parseInt(st.nextToken());
      tree = new HashMap<Integer, ArrayList<Edge>>();
      for(int i = 1; i <= N; i++){
         tree.put(i, new ArrayList<Edge>());
      }
      for(int m = 0; m < M; m++){
         st = new StringTokenizer(sc.readLine());
         int a = Integer.parseInt(st.nextToken());
         int b = Integer.parseInt(st.nextToken());
         int w = Integer.parseInt(st.nextToken());
         tree.get(a).add(new Edge(a,b,w));
         tree.get(b).add(new Edge(b,a,w));
      }
      long ans = prim(1);
      out.println((ct == N) ? ans : "IMPOSSIBLE");
      out.close();
   }
   public static long prim(int source){
      dist = new long[N+1];
      boolean[] visited= new boolean[N+1];
      PriorityQueue<Pair> pq = new PriorityQueue<Pair>();
      Arrays.fill(dist, max);
      dist[source] = 0;
      long ret = 0;
      pq.add(new Pair(0, source));
      while(!pq.isEmpty()){
         Pair p = pq.poll();
         int v = p.b;
         if(visited[v]){
            continue;
         }
         visited[v] = true; ct++; ret += dist[v];
         for(Edge e : tree.get(v)){
            if(e.weight < dist[e.end] && !visited[e.end]){
               dist[e.end] = e.weight;
               pq.add(new Pair(dist[e.end], e.end));
            }
         }
      }
      return ret;
   }
}
class Edge{
   int start, end, weight;
   public Edge(int s, int e, int w){
      start = s;
      end = e;
      weight = w;
   }
}
class Pair implements Comparable<Pair>{
   public long a;
   public int b;
   public Pair(long a, int b){
      this.a = a;
      this.b = b;
   }
   public int compareTo(Pair o){
      if(this.a > o.a){
         return 1;
      }
      else if(this.a == o.a){
         return 0;
      }
      else{
         return -1;
      }
   }
}
```
</JavaSection>

</LanguageSection>

## USACO Problems

<Problems problems={problems.general} />
