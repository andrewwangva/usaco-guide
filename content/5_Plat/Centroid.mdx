---
id: centroid
title: "Centroid Decomposition"
author: Benjamin Qi, Siyong Huang
prerequisites: 
 - dfs
 - SRQ
description: "Decomposing the tree to faciliate path computations"
frequency: 1
---

<!--

TODO:
 - Add more resources

-->

import { Problem } from "../models";

export const problems = {
    general: [
      new Problem("CF", "Ciel the Commander", "problemset/problem/321/C", "Easy", false, ["Centroid"], "Keep setting the centroid to the next rank"),
			new Problem("Plat", "New Barns", "817", "Normal", true, ["Centroid"], "Build centroid decomp on the whole tree first and perform updates for each 'root' as expected."),
			new Problem("CF", "Sherlock's bet to Moriarty", "contest/776/problem/F", "Normal", false, ["Centroid"], "Similar to Ceil the Commander, but annoying to interpret input and order regions"),
			new Problem("CF", "Digit Tree", "contest/715/problem/C", "Normal", false, ["Centroid", "NT"], "M is coprime to 10, so use Euler's Theorem and maps storing mods to count pairs."),
			new Problem("CF", "Double Tree", "contest/1140/problem/G", "Normal", false, ["Centroid", "DP"], "DP + Centroid"),
			new Problem("ojuz", "JOI - Factories", "JOI14_factories", "Normal", false, ["Centroid"], "Very similar to New Barns"),
			new Problem("CF", "Sum of Prefix Sums", "contest/1303/problem/G", "Hard", false, ["Centroid", "CHT"], "Maintain convex hull trick as you iterate through subtrees. It's easier to have a different dfs for querying and updating CHT. Also run forwards and backwards to account for direction of prefix sum."),
      new Problem("YS", "Frequency Table of Tree Distance", "frequency_table_of_tree_distance", "Hard", false, ["Centroid", "FFT"], ""),
      new Problem("DMOJ", "Bob Equilibrium", "dmopc19c7p6", "Hard", false, ["Centroid"], "tight time limit"),
      new Problem("DMOJ", "Time Traveller Imaxblue", "tc19summerh", "Hard", false, ["Centroid"], ""),
      new Problem("ojuz", "JOI - Synchronization", "JOI13_synchronization", "Hard", false, ["Centroid", "Small to Large"], "Looks like $O(N \log^3 N)$ is very fast! When deleting an edge, remember how many systems that edge was used to synchronize. Also, each moment there is a connected component, all computers in the component have the same value."),
			new Problem("CF", "Raining Season", "contest/1019/problem/E", "Very Hard", false, ["Centroid", "CHT", "Set Merging"], "Merge a bunch of smaller convex hull tricks together to create the ultimate convex hull trick"),
      new Problem("Plat", "At Large", "793", "Very Hard", false, ["Centroid"], "tight time limit"),
    ]
};

## Centroid Decomposition

**Centroid Decomposition** is a divide and conquer technique for trees.
The **centroid** of a tree is a node which, if rooted, results in no other nodes having a subtree of size greater than $\frac{N}{2}$.
**Centroid Decomposition** works by repeated splitting the tree and each of the resulting subgraphs at the centroid, producing $O(\log N)$ layers of subgraphs.

### Tutorial

<Resources>
  <Resource source="Carpanese" title="Illustrated Intro to Centroid Decomposition" url="https://medium.com/carpanese/an-illustrated-introduction-to-centroid-decomposition-8c1989d53308" starred></Resource>
  <Resource source="GFG" title="Centroid Decomposition of Tree" url="centroid-decomposition-of-tree"></Resource>
</Resources>

### Implementation

<LanguageSection>

<CPPSection>

<!-- pulled from https://codeforces.com/contest/1303/submission/76216413, which I think is my most recent centroid problem -->

```cpp
bool r[MN];//removed
int s[MN];//subtree size
int dfs(int n, int p = 0)
{
	s[n] = 1;
	for(int x : a[n])
		if(x != p && !r[x])
			s[n] += dfs(x, n);
	return s[n];
}
int get_centroid(int n, int ms, int p = 0)//n = node, ms = size of tree, p = parent
{
	for(int x : a[n])
		if(x != p && !r[x])
			if(s[x]*2 > ms)
				return get_centroid(x, ms, n);
	return n;
}
void centroid(int n = 1)
{
	int C = get_centroid(n, dfs(n));
 
	//do something

	r[C] = 1;
	for(int x : a[C])
		if(!r[x])
			centroid(x);
}
```

</CPPSection>

<JavaSection>

<!-- Modified from above. I can't guarauntee it compiles and functions as expected -->

```java
boolean[] r = new boolean[MN];//removed
int[] s = new int[MN];//subtree size
public int dfs(int n, int p)
{
	s[n] = 1;
	for(int x : a[n])
		if(x != p && !r[x])
			s[n] += dfs(x, n);
	return s[n];
}
public int get_centroid(int n, int ms, int p)//n = node, ms = size of tree, p = parent
{
	for(int x : a[n])
		if(x != p && !r[x])
			if(s[x]*2 > ms)
				return get_centroid(x, ms, n);
	return n;
}
public void centroid(int n)
{
	int C = get_centroid(n, dfs(n, 0), 0);
 
	//do something

	r[C] = 1;
	for(int x : a[C])
		if(!r[x])
			centroid(x);
}
```

</JavaSection>

</LanguageSection>

### Problems

<Problems problems={problems.general} />

*Note:* Unfortunately, it seems like constant factor is especially important for DMOJ. :|
